import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import matter from "gray-matter";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const EN_BLOG_DIR = path.join(__dirname, "../docs/en/blog");
const EN_POSTS_DIR = path.join(EN_BLOG_DIR, "posts");
const EN_CATEGORIES_DIR = path.join(EN_BLOG_DIR, "categories");
const EN_INDEX_FILE = path.join(EN_BLOG_DIR, "index.md");

const ZH_BLOG_DIR = path.join(__dirname, "../docs/zh/blog");
const ZH_POSTS_DIR = path.join(ZH_BLOG_DIR, "posts");
const ZH_CATEGORIES_DIR = path.join(ZH_BLOG_DIR, "categories");
const ZH_INDEX_FILE = path.join(ZH_BLOG_DIR, "index.md");

// Create a new blog post
function createPost(title, lang = "zh") {
  const now = new Date();
  const date = now.toISOString().split("T")[0];
  const time = now.toTimeString().split(" ")[0].replace(/:/g, "-");
  const fileName = `${title
    .toLowerCase()
    .replace(/\s+/g, "-")}-${date}-${time}.md`;

  const postsDir = lang === "zh" ? ZH_POSTS_DIR : EN_POSTS_DIR;
  const filePath = path.join(postsDir, fileName);

  // Create directory if it doesn't exist
  if (!fs.existsSync(postsDir)) {
    fs.mkdirSync(postsDir, { recursive: true });
  }

  const template = `---
title: ${title}
date: ${now.toISOString()}
tags: []
description: ""
---

# ${title}

`;

  fs.writeFileSync(filePath, template);
  console.log(`Created new ${lang.toUpperCase()} post: ${filePath}`);
  return filePath;
}

// Generate category pages
function generateCategories(categories, lang = "zh") {
  const categoriesDir = lang === "zh" ? ZH_CATEGORIES_DIR : EN_CATEGORIES_DIR;

  if (!fs.existsSync(categoriesDir)) {
    fs.mkdirSync(categoriesDir, { recursive: true });
  }

  categories.forEach((category) => {
    const categoryPath = path.join(
      categoriesDir,
      `${category.toLowerCase().replace(/\s+/g, "-")}.md`
    );
    const template = `---
title: ${category}
layout: doc
---

# ${category} Posts

<BlogList category="${category}" />
`;
    fs.writeFileSync(categoryPath, template);
  });
}

// Get latest posts
function getLatestPosts(lang = "zh") {
  const postsDir = lang === "zh" ? ZH_POSTS_DIR : EN_POSTS_DIR;

  if (!fs.existsSync(postsDir)) {
    return [];
  }

  const files = fs.readdirSync(postsDir).filter((file) => file.endsWith(".md"));
  const posts = files.map((file) => {
    const filePath = path.join(postsDir, file);
    const { data } = matter(fs.readFileSync(filePath, "utf-8"));
    return {
      title: data.title || "Untitled",
      date: new Date(data.date),
      link: `/${lang}/blog/posts/${file.replace(".md", "")}`,
      description: data.description || "",
    };
  });

  // Sort by date descending and get top 5
  return posts
    .sort((a, b) => b.date - a.date)
    .slice(0, 5)
    .map((post) => ({
      ...post,
      date: post.date.toISOString().split("T")[0], // Format date as YYYY-MM-DD
    }));
}

// Update index files with latest posts
function updateIndexFiles() {
  // Update English index
  const enLatestPosts = getLatestPosts("en");
  const enPostsList = enLatestPosts
    .map(
      (post) =>
        `- ${post.date}: [${post.title}](${post.link})${
          post.description ? ` - ${post.description}` : ""
        }`
    )
    .join("\n");

  let enContent = fs.readFileSync(EN_INDEX_FILE, "utf-8");
  // Split content at the comment marker
  const [enBeforeComment, ...enRest] = enContent.split(
    "<!-- The list of articles will be automatically generated by the script -->"
  );
  // Reconstruct the file with new content
  const newEnContent =
    enBeforeComment +
    "<!-- The list of articles will be automatically generated by the script -->\n\n" +
    enPostsList;
  fs.writeFileSync(EN_INDEX_FILE, newEnContent);

  // Update Chinese index
  const zhLatestPosts = getLatestPosts("zh");
  const zhPostsList = zhLatestPosts
    .map(
      (post) =>
        `- ${post.date}: [${post.title}](${post.link})${
          post.description ? ` - ${post.description}` : ""
        }`
    )
    .join("\n");

  let zhContent = fs.readFileSync(ZH_INDEX_FILE, "utf-8");
  // Split content at the comment marker
  const [zhBeforeComment, ...zhRest] = zhContent.split(
    "<!-- 文章列表将由脚本自动生成 -->"
  );
  // Reconstruct the file with new content
  const newZhContent =
    zhBeforeComment + "<!-- 文章列表将由脚本自动生成 -->\n\n" + zhPostsList;
  fs.writeFileSync(ZH_INDEX_FILE, newZhContent);

  console.log("Index pages updated with latest posts");
}

// Update blog index
function updateBlogIndex(lang = "zh") {
  const postsDir = lang === "zh" ? ZH_POSTS_DIR : EN_POSTS_DIR;

  if (!fs.existsSync(postsDir)) {
    fs.mkdirSync(postsDir, { recursive: true });
  }

  const files = fs.readdirSync(postsDir).filter((file) => file.endsWith(".md"));
  const categoriesSet = new Set();
  const categoriesMap = {};

  files.forEach((file) => {
    const filePath = path.join(postsDir, file);
    const { data } = matter(fs.readFileSync(filePath, "utf-8"));
    const firstTag = data.tags?.[0] || "Uncategorized";

    categoriesSet.add(firstTag);
    if (!categoriesMap[firstTag]) {
      categoriesMap[firstTag] = [];
    }

    categoriesMap[firstTag].push({
      text: data.title || "Untitled",
      link: `/${lang}/blog/posts/${file.replace(".md", "")}`,
      date: data.date,
    });
  });

  // Sort posts by date within each category
  Object.values(categoriesMap).forEach((posts) => {
    posts.sort((a, b) => new Date(b.date) - new Date(a.date));
  });

  return Array.from(categoriesSet).map((category) => ({
    text: category,
    items: categoriesMap[category] || [],
  }));
}

// Update both language indexes
function updateBothIndexes() {
  const enIndex = updateBlogIndex("en");
  const zhIndex = updateBlogIndex("zh");

  // Write both indexes to the same file
  const indexPath = path.join(__dirname, "blogIndex.js");
  const indexContent = `const enBlogIndex = ${JSON.stringify(enIndex, null, 2)};

const zhBlogIndex = ${JSON.stringify(zhIndex, null, 2)};

export { enBlogIndex, zhBlogIndex };
`;

  fs.writeFileSync(indexPath, indexContent);
  console.log("Blog indexes updated successfully");

  // Update index files with latest posts
  updateIndexFiles();
  console.log("Index pages updated with latest posts");
}

// Create posts in both languages
function createBilingualPosts(zhTitle, enTitle) {
  createPost(zhTitle, "zh");
  createPost(enTitle, "en");
  updateBothIndexes();
}

// Handle command line arguments
const command = process.argv[2];
const title = process.argv[3];
const altLangTitle = process.argv[4];

if (command === "new" && title && altLangTitle) {
  createBilingualPosts(title, altLangTitle);
} else if (command === "new" && title) {
  createPost(title); // Will create Chinese post by default
  updateBothIndexes();
} else if (command === "update") {
  updateBothIndexes();
} else {
  console.log(`
Usage:
  node blog-utils.js new "Chinese Title"                    - Create a new Chinese blog post
  node blog-utils.js new "Chinese Title" "English Title"    - Create blog posts in both languages
  node blog-utils.js update                                 - Update both language indexes and categories
  `);
}
